// Command gettergen generates a Get* and List* method for the specified client
// type into the file `<src-file>-getters.gen.go`
//
// Usage:
//
//	gettergen [-unnamed=name,...] <types...>
package main

import (
	"flag"
	"fmt"
	"log/slog"
	"os"
	"regexp"
	"strings"
	"text/template"
)

/*
TODO: use the Identifier / NamedIdentifier types to identify & generate
 resources from an entire package definition, then output to a single file:

type MyResource struct {
	Identifier

	// ...
}

should generate an unnamed get/list pair

type MyResource struct {
	NamedIdentifier

	// ...
}

should generate a named get/list pair
*/

var (
	unnamedFlag = flag.String("unnamed", "", `set if the get api only accepts ids`)
)

func usage() {
	_, _ = fmt.Fprintf(
		os.Stderr,
		`usage: gettergen [-unnamed=type,...] <file> <type...>`,
	)
	flag.PrintDefaults()
}

func parseUnnamedResources() map[string]struct{} {
	res := make(map[string]struct{})
	defs := *unnamedFlag
	if len(defs) == 0 {
		return nil
	}

	for _, s := range strings.Split(*unnamedFlag, ",") {
		res[s] = struct{}{}
	}
	return res
}

func outFileName(srcFile string) string {
	return fmt.Sprintf(
		"%s-getters.gen.go",
		strings.TrimSuffix(srcFile, ".go"),
	)
}

func main() {
	flag.Usage = usage
	flag.Parse()
	args := flag.Args()

	log := slog.New(slog.NewTextHandler(os.Stderr, nil))

	if err := run(args); err != nil {
		log.Error(err.Error())
		flag.Usage()
	}
}

func run(args []string) error {
	if len(args) < 2 {
		return fmt.Errorf("at least 2 arguments are required")
	}
	typesToGen := args[1:]

	unnamed := parseUnnamedResources()

	f, err := os.Create(outFileName(args[0]))
	if err != nil {
		return fmt.Errorf("opening file: %w", err)
	}
	defer func() { _ = f.Close() }()

	if _, err := f.WriteString(prelude); err != nil {
		return fmt.Errorf("writing prelude: %w", err)
	}

	for _, typeName := range typesToGen {
		_, isUnnamed := unnamed[typeName]

		tArgs := getterTemplateArgs{
			Name:      typeName,
			Plural:    pluralise(typeName),
			Unnamed:   isUnnamed,
			PageType:  pageType(typeName, isUnnamed),
			IdentName: identName(isUnnamed),
			KebabCase: skewer(typeName),
		}

		if err := getterTemplate.Execute(f, tArgs); err != nil {
			return fmt.Errorf("executing template for %q: %w", typeName, err)
		}
	}

	return nil
}

// pluralise pluralises strings with the following rules:
// 1. if it ends in -y, it's converted to -ies
// 2. if it ends in -s, it's converted to -ses
// 3. else append 's'
func pluralise(name string) string {
	if name == "" {
		return ""
	} else if s, cut := strings.CutSuffix(name, "y"); cut {
		return fmt.Sprintf("%sies", s)
	} else if strings.HasSuffix(name, "s") {
		return fmt.Sprintf("%ses", name)
	}
	return fmt.Sprintf("%ss", name)
}

// pageType generates the correct type for the page returned by List* methods.
func pageType(name string, isUnnamed bool) string {
	n := "Named"
	if isUnnamed {
		n = ""
	}
	return fmt.Sprintf("Page[%sAPIResource[%s], %[2]s]", n, name)
}

// identName generates the identifier param name in Get* methods. For unnamed
// resources that only accept IDs, it returns "id" - otherwise, "ident".
func identName(isUnnamed bool) string {
	suffix := "ent"
	if isUnnamed {
		suffix = ""
	}
	return fmt.Sprintf("id%s", suffix)
}

var skewerRegexp = regexp.MustCompile(`([a-z])([A-Z])`)

// skewer converts a PascalCased string to a kebab-cased one.
func skewer(name string) string {
	return strings.ToLower(skewerRegexp.ReplaceAllString(name, `$1-$2`))
}

const prelude = `// Code generated by github.com/nightmarlin/pokeapi/cmd/gettergen@v0"; DO NOT EDIT.

package pokeapi

import "context"
`

var getterTemplate = template.Must(template.New("getter-template").Parse(getterTemplateStr))

type getterTemplateArgs struct {
	Name    string // the name of the type to generate
	Plural  string // the plural form of the type name
	Unnamed bool   // whether the List endpoint for the type returns unnamed api resources

	PageType  string
	IdentName string
	KebabCase string
}

const getterTemplateStr = `
const {{.Name}}Resource Resource = "{{.KebabCase}}"
{{ if .Unnamed }}
// Get{{ .Name }} only accepts the ID of the desired {{ .Name }}.{{ end }}
func (c *Client) Get{{ .Name }}(ctx context.Context, {{ .IdentName }} string) (*{{ .Name }}, error) {
	return do[*{{ .Name }}](ctx, c, c.getURL({{ .Name }}Resource, {{ .IdentName }}), nil)
}
func (c *Client) List{{.Plural}}(ctx context.Context, opts *ListOptions) (*{{ .PageType }}, error) {
	return do[*{{ .PageType }}](ctx, c, c.listURL({{ .Name }}Resource), opts.urlValues())
}
`
